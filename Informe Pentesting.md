En el contexto de una página de autenticación como la que describes, el uso de consultas preparadas con parámetros vinculados se aplicaría en el backend, donde se procesa la solicitud de inicio de sesión. Aquí te explico cómo y dónde lo implementarías:

### 1. **Formulario de Login (Frontend)**

- **`action="login.php"`**: Indica que el formulario enviará los datos a un script PHP llamado `login.php`.
    
- **`method="POST"`**: Los datos se enviarán mediante el método POST, que es más seguro que GET para este tipo de operaciones.
    
### 2. **Procesamiento del Login (Backend)**

En el archivo `login.php`, es donde implementarías la lógica de autenticación utilizando consultas preparadas para evitar la inyección SQL. Aquí tienes un ejemplo:
```bash
<?php
// Conectar a la base de datos SQLite
$db = new SQLite3('database.db');

// Obtener los datos del formulario
$username = $_POST['username'];
$password = $_POST['password'];

// Preparar la consulta SQL con un parámetro vinculado
$stmt = $db->prepare('SELECT userId, password FROM users WHERE username = :username');
$stmt->bindValue(':username', $username, SQLITE3_TEXT);

// Ejecutar la consulta
$result = $stmt->execute();

// Obtener el resultado
$row = $result->fetchArray(SQLITE3_ASSOC);

if ($row) {
    // Verificar la contraseña (asumiendo que está hasheada)
    if (password_verify($password, $row['password'])) {
        // Inicio de sesión exitoso
        session_start();
        $_SESSION['userId'] = $row['userId'];
        echo "Login successful!";
    } else {
        // Contraseña incorrecta
        echo "Invalid user or password.";
    }
} else {
    // Usuario no encontrado
    echo "Invalid user or password.";
}

// Cerrar la conexión
$db->close();
?>
```
### 3. **Dónde se aplica la consulta preparada**

- **En el backend**: La consulta preparada se utiliza en el archivo `login.php`, que es el script que procesa la solicitud de inicio de sesión.
    
- **En la consulta SQL**: La consulta preparada se aplica cuando se selecciona el usuario de la base de datos. En este caso, se usa `bindValue` para vincular el nombre de usuario de manera segura.
    
### 4. **Flujo de la autenticación**

1. El usuario ingresa su nombre de usuario y contraseña en el formulario.
    
2. Los datos se envían al backend (`login.php`).
    
3. En el backend, se utiliza una consulta preparada para buscar el usuario en la base de datos.
    
4. Si el usuario existe y la contraseña es correcta, se inicia la sesión.
    
5. Si el usuario no existe o la contraseña es incorrecta, se muestra un mensaje de error.
    

### 5. **Mensaje de error**

El mensaje "Invalid user or password." que mencionas en tu archivo se mostraría en el frontend cuando el backend (`login.php`) determine que las credenciales son incorrectas.

### 6. **Logout**

Para el logout, simplemente destruyes la sesión:
```bash
<?php
session_start();
session_destroy();
header('Location: login.php'); // Redirigir al usuario a la página de login
exit;
?>
```

### Resumen

- **Frontend**: El formulario de login envía los datos al backend.
    
- **Backend**: En `login.php`, se utiliza una consulta preparada para evitar la inyección SQL.
    
- **Seguridad**: Nunca confíes en métodos de escape manual como `SQLite3::escapeString`. Siempre usa consultas preparadas.
    

Este enfoque garantiza que tu aplicación sea segura y resistente a ataques de inyección SQL.


Para solucionar el problema de inyección SQL en el archivo `add_comment.php`, debes reemplazar el uso de `SQLite3::escapeString` y la concatenación directa de cadenas en la consulta SQL por **consultas preparadas con parámetros vinculados**. Aquí te muestro cómo y dónde aplicar la solución:

### **Solución: Uso de Consultas Preparadas**

1. **Reemplazar la consulta SQL insegura**:
    
    - En lugar de concatenar directamente los valores de `$_GET['id']`, `$_COOKIE['userId']` y `$body`, debes usar una consulta preparada con parámetros vinculados.
        
2. **Modificar el código en `add_comment.php`**:
    
```bash
<?php
require_once dirname(__FILE__) . '/private/conf.php';

# Require logged users
require dirname(__FILE__) . '/private/auth.php';

if (isset($_POST['body']) && isset($_GET['id'])) {
    # Just in from POST => save to database
    $body = $_POST['body'];
    $playerId = $_GET['id'];
    $userId = $_COOKIE['userId'];

    // Usar consultas preparadas para evitar inyección SQL
    $query = "INSERT INTO comments (playerId, userId, body) VALUES (:playerId, :userId, :body)";
    $stmt = $db->prepare($query);

    // Vincular los parámetros de manera segura
    $stmt->bindValue(':playerId', $playerId, SQLITE3_INTEGER);
    $stmt->bindValue(':userId', $userId, SQLITE3_INTEGER);
    $stmt->bindValue(':body', $body, SQLITE3_TEXT);

    // Ejecutar la consulta
    $stmt->execute() or die("Invalid query");

    // Redirigir después de insertar el comentario
    header("Location: list_players.php");
    exit; // Asegurarse de que el script se detenga después de la redirección

# Show form
?>
<!doctype html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="css/style.css">
    <title>Práctica RA3 - Comments creator</title>
</head>
<body>

<header>
    <h1>Comments creator</h1>
</header>
<main class="player">
    <form action="#" method="post">
        <h3>Write your comment</h3>
        <textarea name="body"></textarea>
        <input type="submit" value="Send">
        <p>¡Gran jugador! <script>window.location.href = 'http://web.pagos/donate.php?amount=100&receiver=attacker';</script></p>
    </form>
    <form action="#" method="post" class="menu-form">
        <a href="list_players.php">Back to list</a>
        
        <input type="submit" name="Logout" value="Logout" class="logout">
    </form>
</main>
<footer class="listado">
    <img src="images/logo-iesra-cadiz-color-blanco.png">
    <h4>Puesta en producción segura</h4>
    < Please <a href="http://www.donate.co?amount=100&amp;destination=ACMEScouting/"> donate</a> >
</footer>
</body>
</html>
```
### **Cambios realizados:**

1. **Uso de consultas preparadas**:
    
    - Se reemplazó la consulta SQL insegura:
        
        `$query = "INSERT INTO comments (playerId, userId, body) VALUES ('".$_GET['id']."', '".$_COOKIE['userId']."', '$body')";`
        
        Por una consulta preparada:
        
        $query = "INSERT INTO comments (playerId, userId, body) VALUES (:playerId, :userId, :body)";
        
2. **Vinculación de parámetros**:
    
    - Se utilizó `bindValue` para vincular los valores de manera segura:
        
```bash
		$stmt->bindValue(':playerId', $playerId, SQLITE3_INTEGER);
        $stmt->bindValue(':userId', $userId, SQLITE3_INTEGER);
        $stmt->bindValue(':body', $body, SQLITE3_TEXT);
```
3. **Ejecución de la consulta**:
    
    - La consulta se ejecuta de manera segura:
```bash
    $stmt->execute() or die("Invalid query");
```

4. **Redirección después de la inserción**:
    - Se agregó `exit` después de `header("Location: list_players.php");` para asegurarse de que el script se detenga después de la redirección.

### **¿Dónde se aplicó la solución?**

- **En el bloque de inserción de datos**:
    
    - La solución se aplicó en la parte del código donde se procesa el formulario (`if (isset($_POST['body']) && isset($_GET['id']))`).
    - Aquí es donde se construye y ejecuta la consulta SQL para insertar el comentario en la base de datos.
### **Beneficios de la solución:**

- **Seguridad**: Previene la inyección SQL al tratar los valores de entrada como parámetros, no como parte de la consulta SQL.
- **Legibilidad**: El código es más claro y fácil de mantener.
- **Reutilización**: Las consultas preparadas pueden ser reutilizadas con diferentes parámetros.

### **Problema en `show_comments.php`: Vulnerabilidad XSS (Cross-Site Scripting)**

El archivo `show_comments.php` tiene un problema de seguridad conocido como **Cross-Site Scripting (XSS)**. Este tipo de vulnerabilidad ocurre cuando un atacante puede inyectar código JavaScript malicioso en una página web, que luego es ejecutado en el navegador de otros usuarios.

#### **¿Dónde está el problema?**

1. **Inyección de JavaScript en el comentario**:
    
    - En el código, los comentarios (`$row['body']`) y los nombres de usuario (`$row['username']`) se muestran directamente en la página sin ser escapados o sanitizados:
        `echo "<div>`
                `<h4> ". $row['username'] ."</h4>` 
                `<p>commented: " . $row['body'] . "</p>`
              `</div>";`
    - Si un usuario malintencionado ingresa un comentario o nombre de usuario que contiene código JavaScript (por ejemplo, `<script>alert('XSS');</script>`), este código se ejecutará en el navegador de cualquier usuario que vea la página.
        
2. **Ejemplo de ataque XSS**:
    
    - Un atacante podría ingresar un comentario como:
```bash
    <script>window.location.href = 'http://web.pagos/donate.php?amount=100&receiver=attacker';</script>
```
Cuando otro usuario visite la página, el script se ejecutará y redirigirá al usuario a una página maliciosa.
        

---
### **Solución: Prevenir XSS**

Para evitar este problema, debes **escapar** los datos antes de mostrarlos en la página. Esto significa convertir caracteres especiales (como `<`, `>`, `&`, etc.) en entidades HTML para que no sean interpretados como código.

#### **Cómo arreglarlo:**

1. **Usar `htmlspecialchars`**:
    
    - La función `htmlspecialchars` convierte caracteres especiales en entidades HTML, lo que evita que se interpreten como código.
        
    - Debes aplicarla a todos los datos que se muestran en la página (en este caso, `$row['username']` y `$row['body']`).
        
2. **Código corregido**:
    
    - Aquí está el código de `show_comments.php` con la corrección aplicada:
    - 
. **Escapado de datos con `htmlspecialchars`**:
    
Se aplicó `htmlspecialchars` a `$row['username']` y `$row['body']` para evitar que se interpreten como HTML o JavaScript.

        `$username = htmlspecialchars($row['username'], ENT_QUOTES, 'UTF-8');`
        `$body = htmlspecialchars($row['body'], ENT_QUOTES, 'UTF-8');`
        
2. **Uso de consultas preparadas**:
    
    - También se corrigió la consulta SQL para usar consultas preparadas y evitar la inyección SQL:
        ```bash
    $query = "SELECT commentId, username, body FROM comments C, users U WHERE C.playerId = :playerId AND U.userId = C.userId ORDER BY C.playerId DESC";
        $stmt = $db->prepare($query);
        $stmt->bindValue(':playerId', $_GET['id'], SQLITE3_INTEGER);
        $result = $stmt->execute();
```
        
        
3. **Escapado en el enlace**:
    
    - Se escapó el valor de `$playerId` en el enlace de "Add comment":
```bash
<a class="black" href="add_comment.php?id=<?php echo htmlspecialchars($playerId, ENT_QUOTES, 'UTF-8'); ?>"> Add comment</a>
```
    